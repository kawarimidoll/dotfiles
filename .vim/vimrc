"        _
" __   _(_)_ __ ___  _ __ ___
" \ \ / / | '_ ` _ \| '__/ __|
"  \ V /| | | | | | | | | (__
" (_)_/ |_|_| |_| |_|_|  \___|
"
" @kawarimidoll
" https://twitter.com/kawarimidoll
" https://github.com/kawarimidoll

if !has('nvim')
  set nocompatible
  set encoding=utf-8
  scriptencoding utf-8
  filetype plugin indent on
  packadd matchit
  syntax enable
endif
language ja_JP.UTF-8

let g:did_install_default_menus = 1
let g:did_install_syntax_menu   = 1
let g:did_indent_on             = 1
" load ftplugin to set commentstring
" let g:did_load_ftplugin         = 1
let g:loaded_2html_plugin       = 1
let g:loaded_getscript          = 1
let g:loaded_getscriptPlugin    = 1
let g:loaded_gzip               = 1
let g:loaded_logiPat            = 1
let g:loaded_logipat            = 1
let g:loaded_man                = 1
let g:loaded_matchit            = 1
let g:loaded_matchparen         = 1
let g:loaded_netrw              = 1
let g:loaded_netrwFileHandlers  = 1
let g:loaded_netrwPlugin        = 1
let g:loaded_netrwSettings      = 1
let g:loaded_remote_plugins     = 1
let g:loaded_rrhelper           = 1
let g:loaded_shada_plugin       = 1
let g:loaded_spellfile_plugin   = 1
let g:loaded_sql_completion     = 1
let g:loaded_tar                = 1
let g:loaded_tarPlugin          = 1
let g:loaded_tutor_mode_plugin  = 1
let g:loaded_vimball            = 1
let g:loaded_vimballPlugin      = 1
let g:loaded_zip                = 1
let g:loaded_zipPlugin          = 1
let g:skip_defaults_vim         = 1
let g:skip_loading_mswin        = 1
let g:vimsyn_embed              = 1

" avoid to set expandtab in default ftplugin
let g:markdown_recommended_style = 0

" {{{ Keymap
" https://zenn.dev/kawarimidoll/articles/513d603681ece9
function! s:keymap(force_map, modes, ...) abort
  let arg = join(a:000, ' ')
  let cmd = a:force_map ? 'map' : 'noremap'
  for mode in split(a:modes, '.\zs')
    if stridx('nvsxoilct', mode) < 0
      echoerr '[keymap] invalid mode is detected: ' mode arg
      continue
    endif
    execute mode .. cmd arg
  endfor
endfunction
command! -nargs=+ -bang Keymap call s:keymap(<bang>0, <f-args>)
" }}}

let s:word_1000_dict_path = expand('~/.cache/nvim/google-10000-english-no-swears.txt')
let s:word_1000_dict_url = 'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-no-swears.txt'
if !filereadable(s:word_1000_dict_path)
  call system(printf('curl -fsSLo %s --create-dirs %s', s:word_1000_dict_path, s:word_1000_dict_url))
endif
execute 'set dictionary+=' .. s:word_1000_dict_path

let s:dotfiles_dict_path = expand('~/dotfiles/.config/cspell/dotfiles.txt')
if filereadable(s:dotfiles_dict_path)
  execute 'set dictionary+=' .. s:dotfiles_dict_path
endif

set ambiwidth=single
set breakindent
set breakindentopt=min:50,shift:4,sbr,list:-1
set cedit=\<C-Q>
set clipboard&
set clipboard^=unnamed
set clipboard^=unnamedplus
set completeopt=menu,menuone,noselect
set expandtab
set foldcolumn=0
set formatoptions+=jmM1
set history=2000
set ignorecase
set infercase
set laststatus=1
set lazyredraw
set linebreak
set list
set listchars=tab:^-,trail:~,extends:»,precedes:«,nbsp:%
set nobackup
set nomodeline
set nonumber
set noshowmode
set noswapfile
set nowritebackup
set runtimepath+=~/dotfiles/.vim
set runtimepath+=~/dotfiles/.vim/after
set scrolloff=5
set shiftround
set shiftwidth=2
set shortmess+=scI
set showbreak=↪
set showtabline=0
set signcolumn=number
set smartcase
set smartindent
set softtabstop=2
set splitbelow
set splitright
set switchbuf+=usetab
set tabstop=2
set termguicolors
set title
set updatetime=300
set whichwrap=b,s,h,l,<,>,[,],~
set wildmode=longest,full
set wrap
set wrapscan
if executable('rg')
  set grepprg=rg\ --vimgrep\ --trim\ --hidden\ --glob=!.git
  set grepformat=%f:%l:%c:%m
endif

if has('nvim')
  set inccommand=split
  set scrollback=2000
else
  " :h vim-differences
  set autoindent
  set autoread
  set background=dark
  set backspace=indent,eol,start
  set belloff=all
  set display=lastline
  set hidden
  set hlsearch
  set incsearch
  set nojoinspaces
  set nostartofline
  set ruler
  set smarttab
  set smartcase
  set viminfofile=~/.vim/viminfo
  set ttyfast
  set wildmenu
  set wildoptions=pum,tagfile

  nnoremap Y y$
  nnoremap <C-l> <Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-l><CR>
  inoremap <C-u> <C-g>u<C-u>
  inoremap <C-w> <C-g>u<C-w>
  nnoremap & :&&<CR>

  nnoremap <C-a> <Cmd>call mi#dial#increment(v:count1)<CR>
  nnoremap <C-x> <Cmd>call mi#dial#decrement(v:count1)<CR>

  command! LazyGit tab terminal ++close ++norestore lazygit

  Keymap nx <expr> gc mi#comment#operator_toggle()
  nnoremap <expr> gcc mi#comment#operator_toggle() .. '_'

  " Keymap nx <expr> sa mi#surround#add()
  Keymap nx <expr> sa mi#surround#operator('add')
  nnoremap <expr> sd mi#surround#operator('delete') .. ' '
  nnoremap <expr> sr mi#surround#operator('replace') .. ' '

  let g:mi#ft#multiline = 1
  Keymap nx f <cmd>call mi#ft#smart('f')<CR>
  Keymap nx F <cmd>call mi#ft#smart('F')<CR>
  Keymap nx t <cmd>call mi#ft#smart('t')<CR>
  Keymap nx T <cmd>call mi#ft#smart('T')<CR>
  Keymap nx ; <cmd>call mi#ft#repeat(';')<CR>
  Keymap nx , <cmd>call mi#ft#repeat(',')<CR>
  onoremap <expr> f mi#ft#smart_expr('f')
  onoremap <expr> F mi#ft#smart_expr('F')
  onoremap <expr> t mi#ft#smart_expr('t')
  onoremap <expr> T mi#ft#smart_expr('T')
  onoremap <expr> ; mi#ft#repeat_expr(';')
  onoremap <expr> , mi#ft#repeat_expr(',')
  noremap sf f
  noremap sF F
  noremap st t
  noremap sT T
  noremap s; ;
  noremap s, ,

  nnoremap . <cmd>call mi#common#dot_repeat()<cr>

  nnoremap <c-e> <cmd>call mi#window#resize()<cr>

  try
    packadd vim-jetpack
  catch /^Vim\%((\a\+)\)\=:E919:/
    let s:jetpackfile = expand('~/.vim/pack/jetpack/opt/vim-jetpack/plugin/jetpack.vim')
    let s:jetpackurl = 'https://raw.githubusercontent.com/tani/vim-jetpack/master/plugin/jetpack.vim'
    call system(printf('curl -fsSLo %s --create-dirs %s', s:jetpackfile, s:jetpackurl))
    packadd vim-jetpack
  endtry
  call jetpack#begin()
  call jetpack#add('tani/vim-jetpack', {'opt': 1})
  call jetpack#add('vim-jp/vimdoc-ja')
  call jetpack#end()

  " prev/next use
  nnoremap [u *NNzz<cmd>nohlsearch<cr>
  nnoremap ]u *zz<cmd>nohlsearch<cr>

  " word search keep positions
  nnoremap * *``zz
  nnoremap # #``zz

  " :h termcap-cursor-shape@en
  " https://vim.fandom.com/wiki/Change_cursor_shape_in_different_modes
  if &term =~ 'xterm' || &term == 'win32'
    " Use DECSCUSR escape sequences
    " vertical bar in insert mode
    let &t_SI = "\e[5 q"
    " underline in replace mode
    let &t_SR = "\e[3 q"
    " block in normal mode
    let &t_EI = "\e[1 q"
    " change shape enter / escape termcap
    let &t_ti ..= "\e[1 q"
    let &t_te ..= "\e[0 q"
    "  0 -> default (depends on terminal, normally blinking block)
    "  1 -> blinking block
    "  2 -> solid block
    "  3 -> blinking underscore
    "  4 -> solid underscore
    "  5 -> blinking vertical bar
    "  6 -> solid vertical bar
  endif

endif

let g:my_vimrc = $MYVIMRC
let g:vimrc_snr = expand('<SID>')

command! RcEdit execute 'edit' g:my_vimrc
command! RcReload write | execute 'source' g:my_vimrc | nohlsearch | redraw | echo g:my_vimrc .. ' is reloaded.'

function! s:copy_path(target, with_lnum) abort
  let expr = '%'
  if a:target == 'full path'
    let expr ..= ':p'
  elseif a:target == 'dir name'
    let expr ..= ':h'
  elseif a:target == 'file name'
    let expr ..= ':t'
  endif

  let @*=expand(expr) .. (a:with_lnum ? ':' .. line('.') : '')
  echo 'copy ' .. a:target .. (a:with_lnum ? ' with line num' : '')
endfunction
command! -bang CopyFullPath     call s:copy_path('full path', <bang>0)
command! -bang CopyDirName      call s:copy_path('dir name', <bang>0)
command! -bang CopyFileName     call s:copy_path('file name', <bang>0)
command! -bang CopyRelativePath call s:copy_path('relative path', <bang>0)

command! -nargs=+ -bang Grep  call mi#qf#async_grep(<q-args>, {'add': <bang>0})
command! -nargs=+ -bang GrepF call mi#qf#async_grep(<q-args>, {'add': <bang>0, 'fixed': 1})
command! -nargs=+ -bang LGrep  call mi#qf#async_grep(<q-args>, {'add': <bang>0, 'loc': 1})
command! -nargs=+ -bang LGrepF call mi#qf#async_grep(<q-args>, {'add': <bang>0, 'loc': 1, 'fixed': 1})

command! -nargs=1 -complete=file VDiff vertical diffsplit <args>
command! VDiffAlt execute 'vertical diffsplit' expand('#')

nnoremap <silent> mm <Cmd>call mi#mark#auto_set()<CR>
nnoremap <silent> m, <Cmd>call mi#mark#jump_to_last()<CR>

nnoremap <silent> RR R
nnoremap <expr> R mi#operator#replace()
nnoremap <expr> J mi#operator#join()

" https://zenn.dev/mattn/articles/83c2d4c7645faa
nmap gj gj<SID>g
nmap gk gk<SID>g
nnoremap <script> <SID>gj gj<SID>g
nnoremap <script> <SID>gk gk<SID>g
nmap <SID>g <Nop>
" noremap j gj
" noremap k gk
" noremap gj j
" noremap gk k
noremap gV `[v`]
" https://github.com/yuki-yano/zero.vim/blob/main/plugin/zero.vim
noremap <silent><expr> H getline('.')[:col('.')-2] =~# '^\s\+$' ? '0' : '^'
noremap L $
map M %
nnoremap / /\v
nnoremap ? /\V

nnoremap <C-g> 2<C-g>

nnoremap s <NOP>
nnoremap so <Cmd>source<Bar>nohlsearch<CR>
nnoremap s/ :%s/\v
nnoremap s? :%s/\V
nnoremap S :%s/\V\<<C-r><C-w>\>//g<Left><Left>

" https://thinca.hatenablog.com/entry/q-as-prefix-key-in-vim
nnoremap <script> <expr> q empty(reg_recording()) ? '<sid>(q)' : 'q'
nnoremap <sid>(q)q qq
nnoremap Q @q
nnoremap <sid>(q)/ q/
nnoremap <sid>(q): q:
nnoremap <sid>(q)a <Cmd>call mi#qf#add_curpos()<CR>
nnoremap <sid>(q)c <Cmd>call mi#qf#toggle()<CR>
nnoremap <sid>(q)g :<C-u>global/^/normal<Space>
nnoremap <sid>(q)h <Cmd>call mi#common#half_move('left', v:count1)<CR>
nnoremap <sid>(q)i <Cmd>call mi#common#half_move('center', v:count1)<CR>
nnoremap <sid>(q)j <Cmd>call mi#common#half_move('down', v:count1)<CR>
nnoremap <sid>(q)k <Cmd>call mi#common#half_move('up', v:count1)<CR>
nnoremap <sid>(q)l <Cmd>call mi#common#half_move('right', v:count1)<CR>
nnoremap <sid>(q)o <Cmd>only!<CR>
nnoremap <sid>(q)t <C-^>
nnoremap <sid>(q)x <Cmd>call mi#qf#clear()<CR>
" reserve for neovim
if has('nvim')
  for c in ['d', 'z']
    execute printf('nnoremap <sid>(q)%s <Plug>(rc-q-%s)', c, c)
  endfor
endif

nnoremap p ]p`]
nnoremap P [P`]
"nnoremap gp p
"nnoremap gP P
nnoremap x "_d
nnoremap X "_D
" nnoremap ' `

nnoremap <silent><expr> [b '<Cmd>' .. v:count1 .. 'bprevious<CR>'
nnoremap <silent><expr> ]b '<Cmd>' .. v:count1 .. 'bnext<CR>'
nnoremap [B <Cmd>bfirst<CR>
nnoremap ]B <Cmd>blast<CR>
nnoremap [q <Cmd>call mi#qf#cycle_p()<CR>
nnoremap ]q <Cmd>call mi#qf#cycle_n()<CR>
nnoremap <silent><expr> [Q '<Cmd>' .. v:count1 .. 'colder<CR>'
nnoremap <silent><expr> ]Q '<Cmd>' .. v:count1 .. 'cnewer<CR>'
nnoremap [w <C-w>w
nnoremap ]w <C-w>W
nnoremap [m [`
nnoremap ]m ]`
nnoremap [p {
nnoremap ]p }

" for 40% keyboard
nmap <BS> [
nmap ' ]

" https://twitter.com/mo_naqa/status/1467626946293284865
" nnoremap gf gFzz
" nnoremap gx :<C-u>!open <C-r><C-a>
command! -nargs=* SmartOpen call mi#open#smart_open(<q-args>)
Keymap nx gf <Cmd>call mi#open#smart_open()<CR>

"for c in g:mi#const#alpha_all->split('\zs')
"  execute 'nnoremap <Space>' .. c '<NOP>'
"endfor
nnoremap <Space>b <Cmd>call mi#fzf#bufs()<CR>
nnoremap <Space>d <Cmd>call mi#buf#delete()<CR>
nnoremap <Space>D <Cmd>call mi#buf#delete({'force': v:true})<CR>
nnoremap <Space>f <Cmd>call mi#fzf#files()<CR>
nnoremap <Space>g <Cmd>copy.<CR>
nnoremap <Space>G <Cmd>copy-1<CR>
nnoremap <space>h <Cmd>call mi#fzf#mru()<CR>
nnoremap <Space>m <Cmd>marks<bar>execute 'normal! `' .. input('jump to: ')<CR>
nnoremap <expr> <Space>o mi#blank#below()
nnoremap <expr> <Space>O mi#blank#above()
nnoremap <Space>p <cmd>call mi#common#trim()<cr>mzgg=G`z
nnoremap <Space>q <cmd>confirm quit<CR>
nnoremap <Space>r <Cmd>registers<bar>execute 'normal "' .. input('paste reg: ') .. 'p'<CR>
nnoremap <Space>Q <cmd>quitall!<CR>
nnoremap <Space>w <cmd>w<CR>
nnoremap <Space>wq <cmd>confirm wq<CR>
nnoremap <Space>; @:
nnoremap <Space>/ :<C-u>Grep<Space>
nnoremap <Space>? :<C-u>GrepF <C-r><C-w>
xnoremap <Space>? "zy:<C-u>GrepF <C-r>z
nnoremap <silent><expr> <C-k> '<Cmd>move-1-' .. v:count1 .. '<CR>=l'
nnoremap <silent><expr> <C-j> '<Cmd>move+'   .. v:count1 .. '<CR>=l'
nnoremap <Space>L <Cmd>LazyGit<CR>

" https://zenn.dev/kawarimidoll/articles/17dad86545cbb4
nnoremap <C-f> <Cmd>set scroll=0<CR><Cmd>execute 'normal!' repeat('<C-d>', v:count1 * 2)<CR>
nnoremap <C-b> <Cmd>set scroll=0<CR><Cmd>execute 'normal!' repeat('<C-u>', v:count1 * 2)<CR>

" command
cnoremap <expr> s getcmdtype() == ':' && getcmdline() == 's' ? '<BS>%s/' : 's'
cnoremap <expr> % getcmdtype() == ':' && getcmdpos() > 2 && getcmdline()[getcmdpos()-2] == '%' ?
      \ '<BS>' .. expand('%:h') .. '/' : '%'
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> <C-n> wildmenumode() ? '<C-n>' : '<Down>'
cnoremap <expr> <C-p> wildmenumode() ? '<C-p>' : '<Up>'
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
cnoremap <C-r><C-r> <C-r><C-r>*
cnoremap <expr> <C-k> repeat('<Del>', strchars(getcmdline()[getcmdpos() - 1:]))

cnoremap <expr> <C-x> mi#magic#expr()

" insert
inoremap <silent> <C-r><C-r> <C-r><C-r>*
inoremap <C-k> <C-o>D
inoremap <expr> <Tab>   pumvisible() ? '<C-n>' : '<C-t>'
inoremap <expr> <S-Tab> pumvisible() ? '<C-p>' : '<C-d>'
inoremap <C-g><C-u> <esc>gUvbgi
inoremap <C-g><C-l> <esc>guvbgi

" visual
xnoremap p P
xnoremap <silent> y y`]
xnoremap x "_x
xnoremap < <gv
xnoremap > >gv
" xmap <Tab>   >
" xmap <S-Tab> <
xnoremap <silent><C-k> :m'<-2<CR>gv=gv
xnoremap <silent><C-j> :m'>+1<CR>gv=gv
xnoremap S "zy:%s/<C-r>z//gce<Left><Left><Left><Left>
" ref: github.com/monaqa/dotfiles/blob/master/.config/nvim/scripts/keymap.vim#L65-L66
xnoremap * "zy/\V<C-r><C-r>=substitute(escape(@z, '/\'), '\_s\+', '\\_s\\+', 'g')<CR><CR>``
xnoremap # "zy?\V<C-r><C-r>=substitute(escape(@z, '/\'), '\_s\+', '\\_s\\+', 'g')<CR><CR>``
xnoremap R "zy:,$s//<C-r><C-r>=escape(@z, '/\&~')<CR>/gce<Bar>1,''-&&<CR>

" operator
onoremap x d

" terminal
tnoremap <C-w><C-n> <C-\><C-n>
tnoremap <C-p> <Up>
tnoremap <C-n> <Down>

" https://qiita.com/monaqa/items/dcd43a53d3040293142a
let s:jp_digraphs = [
      \    ['aa', 'あ'], ['ii', 'い'], ['uu', 'う'], ['ee', 'え'], ['oo', 'お'],
      \    ['aA', 'ぁ'], ['iI', 'ぃ'], ['uU', 'ぅ'], ['eE', 'ぇ'], ['oO', 'ぉ'],
      \    ['Aa', 'ア'], ['Ii', 'イ'], ['Uu', 'ウ'], ['Ee', 'エ'], ['Oo', 'オ'],
      \    ['AA', 'ァ'], ['II', 'ィ'], ['UU', 'ゥ'], ['EE', 'ェ'], ['OO', 'ォ'],
      \    ['nn', 'ん'], ['Nn', 'ン'], ['j(', '（'], ['j)', '）'], ['j[', '「'],
      \    ['j]', '」'], ['j{', '『'], ['j}', '』'], ['j<', '【'], ['j>', '】'],
      \    ['j,', '、'], ['j.', '。'], ['j!', '！'], ['j?', '？'], ['j:', '：'],
      \    ['j0', '０'], ['j1', '１'], ['j2', '２'], ['j3', '３'], ['j4', '４'],
      \    ['j5', '５'], ['j6', '６'], ['j7', '７'], ['j8', '８'], ['j9', '９'],
      \    ['j~', '〜'], ['j/', '・'], ['j ', '　'],
      \  ]
call digraph_setlist(s:jp_digraphs)
noremap f<C-j> f<C-k>j
noremap F<C-j> F<C-k>j
noremap t<C-j> t<C-k>j
noremap T<C-j> T<C-k>j

Keymap xo il <Cmd>call mi#textobject#line()<CR>
Keymap xo al <Cmd>call mi#textobject#line({'no_trim': 1})<CR>
Keymap xo iu <Cmd>call mi#textobject#fname()<CR>
Keymap xo iy <Cmd>call mi#textobject#lastpaste()<CR>
Keymap xo id <Cmd>call mi#textobject#datetime()<CR>
Keymap xo iA <Cmd>call mi#textobject#alphabet()<CR>
Keymap xo aA <Cmd>call mi#textobject#alphabet({'with_num': 1})<CR>
Keymap xo ie <Cmd>call mi#textobject#entire()<CR>
Keymap xo ae <Cmd>call mi#textobject#entire({'charwise': 1})<CR>
Keymap xo iS <Cmd>call mi#textobject#space()<CR>
Keymap xo aS <Cmd>call mi#textobject#space({'with_tab': 1})<CR>
Keymap xo io <Cmd>call mi#textobject#outline()<CR>
Keymap xo ao <Cmd>call mi#textobject#outline({'from_parent': 1, 'with_blank': 1})<CR>

if !has('nvim')
  Keymap xo i<space> <cmd>call mi#textobject#between(' ', 0)<cr>
  Keymap xo a<space> <cmd>call mi#textobject#between(' ', 1)<cr>
  Keymap xo i<bar> <cmd>call mi#textobject#between("\<bar>", 0)<cr>
  Keymap xo a<bar> <cmd>call mi#textobject#between("\<bar>", 1)<cr>
  " does not works <bslash>...
  " Keymap xo i<bslash> <cmd>call mi#textobject#between("\<bslash>", 0)<cr>
  " Keymap xo a<bslash> <cmd>call mi#textobject#between("\<bslash>", 1)<cr>
  for i in range(33, 126)
    let c = nr2char(i)
    if c !~ '[[:punct:]]' || stridx('\|<>(){}[]"`''', c) >= 0
      continue
    endif
    execute 'Keymap xo i' .. c .. ' <cmd>call mi#textobject#between(''' .. c .. ''', 0)<cr>'
    execute 'Keymap xo a' .. c .. ' <cmd>call mi#textobject#between(''' .. c .. ''', 1)<cr>'
  endfor
endif

" {{{ Rename
" https://vim-jp.org/vim-users-jp/2009/05/27/Hack-17.html
command! -nargs=1 -complete=file Rename
      \ execute 'autocmd BufWritePost <buffer> ++once call delete("' .. expand('%') .. '")' |
      \ file <args>
" }}}

" {{{ EditProjectMru()
" https://zenn.dev/kawarimidoll/articles/057e0c26c6d6e3
" remove function after startup because it is only for `$ vim -c 'call EditProjectMru()'`
function! EditProjectMru() abort
  execute 'edit' get(mi#mru#list(v:true), 0, '')
endfunction
" }}}

function! s:apply_user_highlight() abort
  highlight Reverse    cterm=reverse gui=reverse
  highlight Pmenu      ctermfg=254 ctermbg=237 guifg=#e3e1e4 guibg=#37343a
  highlight PmenuSel   ctermfg=237 ctermbg=254 guifg=#37343a guibg=#e3e1e4
  highlight PmenuSbar  ctermbg=238 guibg=#423f46
  highlight PmenuThumb ctermbg=255 guibg=#f8f8f2
  highlight Underlined ctermfg=NONE cterm=underline guifg=NONE gui=underline
  highlight ExtraWhitespace ctermbg=darkmagenta guibg=darkmagenta
endfunction

" https://zenn.dev/hokorobi/articles/98f79339d7d114
function! s:syntax_off_on_heavy_file()
  if getfsize(@%) > 512 * 1000
    setlocal syntax=OFF
    call interrupt()
    echo 'syntax off: too heavy file.'
  endif
endfunction

command! -nargs=* -bang -complete=command Capture call mi#capture#run(<bang>0, <q-args>)

function! s:visualize_autocmds()
  let events = [
        \ 'FileType', 'BufNewFile', 'BufEnter', 'BufRead', 'BufWinEnter', 'WinEnter',
        \ 'TabEnter', 'WinNew', 'TabNew', 'VimEnter',
        \ ]

  augroup v_au
    if exists('s:enable_v_au')
      autocmd!
      unlet! s:enable_v_au
      echo 'disable visualize autocmds'
    else
      for event in events
        execute printf('autocmd %s * echomsg ''au %s'' expand(''<amatch>'')', event, event)
      endfor
      let s:enable_v_au = 1
      echo 'enable visualize autocmds'
    endif
  augroup END
endfunction
command! VisualizeAutocmds call s:visualize_autocmds()
" enable when vim is starting
" call s:visualize_autocmds()

function! s:pin_help_buffer()
  let is_help = &buftype == 'help'
  if is_help
    let w:pin_buf_type = 'help'
    return
  endif

  let is_not_pinned = get(w:, 'pin_buf_type', '') != 'help'
  if is_not_pinned
    return
  endif

  let bufnr = bufnr()
  for winnr in range(1, winnr('$'))
    let win_id = win_getid(winnr)
    if getwinvar(win_id, 'pin_buf_type') == ''
      edit #
      call win_gotoid(win_id)
      execute 'buffer' bufnr
      return
    endif
  endfor
  echomsg 'all buffers are pinned.'
endfunction

" skip autocmds after vim is started
if !has('vim_starting')
  finish
endif

augroup vimrc
  autocmd!

  autocmd BufEnter * call s:pin_help_buffer()
  autocmd BufEnter * call s:syntax_off_on_heavy_file()

  " Highlight extra whitespaces
  " https://zenn.dev/kawarimidoll/articles/450a1c7754bde6
  " u00A0 ' ' no-break space
  " u2000 ' ' en quad
  " u2001 ' ' em quad
  " u2002 ' ' en space
  " u2003 ' ' em space
  " u2004 ' ' three-per em space
  " u2005 ' ' four-per em space
  " u2006 ' ' six-per em space
  " u2007 ' ' figure space
  " u2008 ' ' punctuation space
  " u2009 ' ' thin space
  " u200A ' ' hair space
  " u200B '​' zero-width space
  " u3000 '　' ideographic (zenkaku) space
  autocmd VimEnter,WinEnter * if !exists('w:highlight_extra_whitespace')
        \ | let w:highlight_extra_whitespace = matchadd('ExtraWhitespace', "[\u00A0\u2000-\u200B\u3000]")
        \ | endif
  autocmd ColorScheme * call s:apply_user_highlight()

  autocmd User VimReady
        \ delfunction! EditProjectMru
        \ | call mi#git#ensure_root()
        \ | call mi#register#clear()
        \ | execute 'autocmd TextYankPost * call mi#register#collect_yank_history(10)'
        \ | execute 'autocmd BufEnter,BufReadPost * call mi#mru#save()'

  autocmd BufNewFile * ++nested call mi#open#reopen_with_lnum()

  if has('nvim')
    " https://jdhao.github.io/2020/05/22/highlight_yank_region_nvim/
    autocmd TextYankPost * silent! lua vim.highlight.on_yank({ timeout=500 })
    autocmd TermOpen * if exists('w:highlight_extra_whitespace') && exists('b:terminal_job_id')
          \ | silent! call matchdelete(w:highlight_extra_whitespace)
          \ | endif
  else

    if has('vim_starting')
      execute 'colorscheme' ['desert', 'slate', 'habamax'][rand(srand()) % 3]
    endif

    " https://www.statox.fr/posts/2020/07/vim_flash_yanked_text/
    autocmd User VimReady
          \ execute 'autocmd CursorMoved * call mi#highlight#cursorword(''Underlined'')'
          \ | execute 'autocmd CursorMoved,CursorMovedI * call mi#highlight#match_paren(''Underlined'')'
          \ | execute 'autocmd TextYankPost * silent! call mi#highlight#on_yank({''timeout'': 500})'
          \ | execute 'autocmd WinEnter * call mi#qf#quit_if_last_buf()'
          \ | execute 'autocmd FileType qf call mi#qf#fit_window({''min'': 3, ''max'': 10})'
          \ | execute 'autocmd FileType qf call mi#qf#preview()'
          \ | source ~/dotfiles/.vim/autoload/mi/searchprop.vim
          \ | source ~/dotfiles/.vim/autoload/mi/substitutor.vim
          \ | call mi#pair#keymap_set(['{}', '[]', '()', "''", '""', '``'])
  endif

  " {{{ restore-cursor
  " :h restore-cursor
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |   execute 'normal! g`"zz'
        \ | endif
  " }}}

  " {{{ ensure_dir
  " https://vim-jp.org/vim-users-jp/2011/02/20/Hack-202.html
  function! s:ensure_dir(dir)
    if !isdirectory(a:dir) && confirm('"' . a:dir . '" does not exist. Create?', "y\nN")
      call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
    endif
  endfunction
  autocmd BufWritePre * call s:ensure_dir(expand('<afile>:p:h'))
  " }}}
augroup END

call timer_start(100, {->execute('doautocmd User VimReady')})
