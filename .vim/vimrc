"        _
" __   _(_)_ __ ___  _ __ ___
" \ \ / / | '_ ` _ \| '__/ __|
"  \ V /| | | | | | | | | (__
" (_)_/ |_|_| |_| |_|_|  \___|
"
" @kawarimidoll
" https://twitter.com/kawarimidoll
" https://github.com/kawarimidoll

if !has('nvim')
  set nocompatible
  set encoding=utf-8
  scriptencoding utf-8
  filetype plugin indent on
  runtime macros/matchit.vim
  syntax enable
endif

let g:did_install_default_menus = 1
let g:did_install_syntax_menu   = 1
let g:did_indent_on             = 1
" load ftplugin to set commentstring
" let g:did_load_ftplugin         = 1
let g:loaded_2html_plugin       = 1
let g:loaded_getscript          = 1
let g:loaded_getscriptPlugin    = 1
let g:loaded_gzip               = 1
let g:loaded_logiPat            = 1
let g:loaded_logipat            = 1
let g:loaded_man                = 1
let g:loaded_matchit            = 1
let g:loaded_matchparen         = 1
let g:loaded_netrw              = 1
let g:loaded_netrwFileHandlers  = 1
let g:loaded_netrwPlugin        = 1
let g:loaded_netrwSettings      = 1
let g:loaded_remote_plugins     = 1
let g:loaded_rrhelper           = 1
let g:loaded_shada_plugin       = 1
let g:loaded_spellfile_plugin   = 1
let g:loaded_sql_completion     = 1
let g:loaded_tar                = 1
let g:loaded_tarPlugin          = 1
let g:loaded_tutor_mode_plugin  = 1
let g:loaded_vimball            = 1
let g:loaded_vimballPlugin      = 1
let g:loaded_zip                = 1
let g:loaded_zipPlugin          = 1
let g:skip_loading_mswin        = 1
let g:vimsyn_embed              = 1

" {{{ Keymap
" https://zenn.dev/kawarimidoll/articles/513d603681ece9
function! s:keymap(modes, ...) abort
  let arg = join(a:000, ' ')
  for mode in split(a:modes, '.\zs')
    if index(split('nvsxoilct', '.\zs'), mode) < 0
      echoerr 'Invalid mode is detected: ' . mode
      continue
    endif
    execute mode .. 'noremap' arg
  endfor
endfunction
command! -nargs=+ Keymap call s:keymap(<f-args>)
" }}}

let s:word_1000_dict_path = '~/.cache/nvim/google-10000-english-no-swears.txt'
if !filereadable(expand(s:word_1000_dict_path))
  silent execute '!curl --create-dirs -fLo ' .. s:word_1000_dict_path ..
        \ 'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-no-swears.txt'
endif
execute 'set dictionary+=' .. s:word_1000_dict_path

let s:dotfiles_dict_path = '~/dotfiles/.config/cspell/dotfiles.txt'
if filereadable(expand(s:dotfiles_dict_path))
  execute 'set dictionary+=' .. s:dotfiles_dict_path
endif

set ambiwidth=single
set breakindent
set breakindentopt=min:50,shift:4,sbr,list:-1
set cedit=\<C-Q>
set clipboard&
set clipboard^=unnamed
set clipboard^=unnamedplus
set completeopt=menu,menuone,noselect
set expandtab
set foldcolumn=0
set formatoptions+=jmM1
set history=2000
set ignorecase
set infercase
set laststatus=1
set lazyredraw
set linebreak
set list
set listchars=tab:^-,trail:~,extends:»,precedes:«,nbsp:%
set nobackup
set nomodeline
set nonumber
set noshowmode
set noswapfile
set nowritebackup
set runtimepath+=~/dotfiles/.vim
set runtimepath+=~/dotfiles/.vim/after
set scrolloff=5
set shiftround
set shiftwidth=2
set shortmess+=scI
set showbreak=↪
set showtabline=0
set signcolumn=number
set smartcase
set smartindent
set softtabstop=2
set splitbelow
set splitright
set switchbuf+=usetab
set tabstop=2
set termguicolors
set title
set updatetime=300
set whichwrap=b,s,h,l,<,>,[,],~
set wildmode=longest,full
set wrap
set wrapscan
if executable('rg')
  set grepprg=rg\ --line-number\ --column\ --no-heading\ --color=never\ --hidden\ --trim\ --glob\ '!**/.git/*'
  set grepformat=%f:%l:%c:%m
endif

if has('nvim')
  set inccommand=split
  set scrollback=2000
else
  " :h vim-differences
  set autoindent
  set autoread
  set background=dark
  set backspace=indent,eol,start
  set belloff=all
  set display=lastline
  set hidden
  set hlsearch
  set incsearch
  set nojoinspaces
  set nostartofline
  set ruler
  set smarttab
  set smartcase
  set viminfofile=~/.vim/viminfo
  set ttyfast
  set wildmenu
  set wildoptions=pum,tagfile

  nnoremap Y y$
  nnoremap <C-l> <Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-l><CR>
  inoremap <C-u> <C-g>u<C-u>
  inoremap <C-w> <C-g>u<C-w>
  nnoremap & :&&<CR>

  nnoremap <C-a> <Cmd>call mi#dial#increment(v:count1)<CR>
  nnoremap <C-x> <Cmd>call mi#dial#decrement(v:count1)<CR>

  command! LazyGit tab terminal ++close ++norestore lazygit

  Keymap nx <expr> gc mi#comment#operator_toggle()
  nnoremap <expr> gcc mi#comment#operator_toggle() .. '_'

  " Keymap nx <expr> sa mi#surround#add()
  Keymap nx <expr> sa mi#surround#operator('add')

  let g:mi#ft#multiline = 1
  Keymap nx f <cmd>call mi#ft#smart('f')<CR>
  Keymap nx F <cmd>call mi#ft#smart('F')<CR>
  Keymap nx t <cmd>call mi#ft#smart('t')<CR>
  Keymap nx T <cmd>call mi#ft#smart('T')<CR>
  Keymap nx ; <cmd>call mi#ft#repeat(';')<CR>
  Keymap nx , <cmd>call mi#ft#repeat(',')<CR>
  onoremap <expr> f mi#ft#smart_expr('f')
  onoremap <expr> F mi#ft#smart_expr('F')
  onoremap <expr> t mi#ft#smart_expr('t')
  onoremap <expr> T mi#ft#smart_expr('T')
  onoremap <expr> ; mi#ft#repeat_expr(';')
  onoremap <expr> , mi#ft#repeat_expr(',')
  noremap sf f
  noremap sF F
  noremap st t
  noremap sT T
  noremap s; ;
  noremap s, ,

  nnoremap . <cmd>call mi#common#dot_repeat()<cr>

  nnoremap <c-e> <cmd>call mi#window#resize()<cr>

  let s:jetpackfile = expand('~/.vim/pack/jetpack/opt/vim-jetpack/plugin/jetpack.vim')
  let s:jetpackurl = 'https://raw.githubusercontent.com/tani/vim-jetpack/master/plugin/jetpack.vim'
  if !filereadable(s:jetpackfile)
    call system(printf('curl -fsSLo %s --create-dirs %s', s:jetpackfile, s:jetpackurl))
  endif
  packadd vim-jetpack
  call jetpack#begin()
  call jetpack#add('tani/vim-jetpack', {'opt': 1})
  call jetpack#add('vim-jp/vimdoc-ja')
  call jetpack#end()

  " prev/next use
  nnoremap [u *NNzz<cmd>nohlsearch<cr>
  nnoremap ]u *zz<cmd>nohlsearch<cr>

  " word search keep positions
  nnoremap * *``zz
  nnoremap # #``zz
endif

let g:my_vimrc = $MYVIMRC

command! RcEdit execute 'edit' g:my_vimrc
command! RcReload write | execute 'source' g:my_vimrc | nohlsearch | redraw | echo g:my_vimrc .. ' is reloaded.'

command! CopyFullPath     let @*=expand('%:p') | echo 'copy full path'
command! CopyDirName      let @*=expand('%:h') | echo 'copy dir name'
command! CopyFileName     let @*=expand('%:t') | echo 'copy file name'
command! CopyRelativePath let @*=expand('%:h')..'/'..expand('%:t') | echo 'copy relative path'

command! -nargs=+ Grep call mi#qf#grep(<q-args>)
command! -nargs=+ GrepF call mi#qf#grep('--fixed-strings -- ' .. <q-args>)
command! -nargs=+ LGrep call mi#qf#lgrep(<q-args>)
command! -nargs=+ LGrepF call mi#qf#lgrep('--fixed-strings -- ' .. <q-args>)

command! -nargs=1 -complete=file VDiff vertical diffsplit <args>
command! VDiffAlt execute 'vertical diffsplit' expand('#')

nnoremap <silent> mm <Cmd>call mi#mark#auto_set()<CR>
nnoremap <silent> m, <Cmd>call mi#mark#jump_to_last()<CR>

nnoremap <expr> gp mi#operator#replace()
nnoremap <expr> J mi#operator#join()

noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap gV `[v`]
" https://github.com/yuki-yano/zero.vim/blob/main/plugin/zero.vim
noremap <silent><expr> H getline('.')[:col('.')-2] =~# '^\s\+$' ? '0' : '^'
noremap L $
map M %
nnoremap / /\v

nnoremap s <NOP>
nnoremap so <Cmd>source<Bar>nohlsearch<CR>
nnoremap s/ :%s/
nnoremap S :%s/\V\<<C-r><C-w>\>//g<Left><Left>
nnoremap <script> <expr> q empty(reg_recording()) ? '<sid>(q)' : 'q'
" for c in g:mi#const#alpha_all->split('\zs')
"   execute 'nnoremap <sid>(q)' .. c '<NOP>'
" endfor
nnoremap <sid>(q)q qq
nnoremap Q @q
nnoremap <sid>(q)a <Cmd>call mi#qf#add_curpos()<CR>
nnoremap <sid>(q)c <Cmd>call mi#qf#toggle()<CR>
nnoremap <sid>(q)h <Cmd>call mi#common#half_move('left', v:count1)<CR>
nnoremap <sid>(q)i <Cmd>call mi#common#half_move('center', v:count1)<CR>
nnoremap <sid>(q)j <Cmd>call mi#common#half_move('down', v:count1)<CR>
nnoremap <sid>(q)k <Cmd>call mi#common#half_move('up', v:count1)<CR>
nnoremap <sid>(q)l <Cmd>call mi#common#half_move('right', v:count1)<CR>
nnoremap <sid>(q)o <Cmd>only!<CR>
nnoremap <sid>(q)t <C-^>
nnoremap <sid>(q)x <Cmd>call mi#qf#clear()<CR>

nnoremap p ]p`]
nnoremap P [P`]
"nnoremap gp p
"nnoremap gP P
nnoremap x "_d
nnoremap X "_D
nnoremap ' `

nnoremap <silent><expr> [b '<Cmd>' .. v:count1 .. 'bprevious<CR>'
nnoremap <silent><expr> ]b '<Cmd>' .. v:count1 .. 'bnext<CR>'
nnoremap [B <Cmd>bfirst<CR>
nnoremap ]B <Cmd>blast<CR>
nnoremap [q <Cmd>call mi#qf#cycle(-v:count1)<CR>
nnoremap ]q <Cmd>call mi#qf#cycle(v:count1)<CR>
nnoremap [Q <Cmd>cfirst<CR>
nnoremap ]Q <Cmd>clast<CR>
nnoremap [w <C-w>w
nnoremap ]w <C-w>W
nnoremap [m [`
nnoremap ]m ]`

" https://twitter.com/mo_naqa/status/1467626946293284865
" nnoremap gf gFzz
" nnoremap gx :<C-u>!open <C-r><C-a>
command! -nargs=* SmartOpen call mi#open#smart_open(<q-args>)
Keymap nx gf <Cmd>call mi#open#smart_open()<CR>

"for c in g:mi#const#alpha_all->split('\zs')
"  execute 'nnoremap <Space>' .. c '<NOP>'
"endfor
nnoremap <Space>b <Cmd>call mi#fzf#bufs()<CR>
nnoremap <Space>d <Cmd>call mi#buf#delete()<CR>
nnoremap <Space>D <Cmd>call mi#buf#delete({'force': v:true})<CR>
nnoremap <Space>f <Cmd>call mi#fzf#files()<CR>
nnoremap <Space>g <Cmd>copy.<CR>
nnoremap <Space>G <Cmd>copy-1<CR>
nnoremap <space>h <Cmd>call mi#fzf#mru()<CR>
nnoremap <Space>m <Cmd>marks<bar>execute 'normal! `' .. input('jump to: ')<CR>
nnoremap <expr> <Space>o mi#blank#below()
nnoremap <expr> <Space>O mi#blank#above()
nnoremap <Space>p <cmd>call mi#common#trim()<cr>mzgg=G`z
nnoremap <Space>q <cmd>confirm quit<CR>
nnoremap <Space>r <Cmd>registers<bar>execute 'normal "' .. input('paste reg: ') .. 'p'<CR>
nnoremap <Space>Q <cmd>quitall!<CR>
nnoremap <Space>w <cmd>w<CR>
nnoremap <Space>wq <cmd>confirm wq<CR>
nnoremap <Space>; @:
nnoremap <Space>/ :<C-u>Grep ''<Left>
nnoremap <Space>? :<C-u>GrepF ''<Left><C-r><C-w>
xnoremap <Space>? "zy:<C-u>GrepF ''<Left><C-r>z
nnoremap <silent><expr> <C-k> '<Cmd>move-1-' .. v:count1 .. '<CR>=l'
nnoremap <silent><expr> <C-j> '<Cmd>move+'   .. v:count1 .. '<CR>=l'
nnoremap <Space>L <Cmd>LazyGit<CR>

nnoremap <C-f> <Cmd>set scroll=0<CR><Cmd>execute 'normal!' repeat('<C-d>', v:count1 * 2)<CR>
nnoremap <C-b> <Cmd>set scroll=0<CR><Cmd>execute 'normal!' repeat('<C-u>', v:count1 * 2)<CR>

" command
cnoremap <expr> s getcmdtype() == ':' && getcmdline() == 's' ? '<BS>%s/' : 's'
cnoremap <expr> % getcmdtype() == ':' && getcmdpos() > 2 && getcmdline()[getcmdpos()-2] == '%' ?
      \ '<BS>' .. expand('%:h') .. '/' : '%'
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> <C-n> wildmenumode() ? '<C-n>' : '<Down>'
cnoremap <expr> <C-p> wildmenumode() ? '<C-p>' : '<Up>'
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
cnoremap <C-r><C-r> <C-r><C-r>*
cnoremap <C-g> <C-c>
cnoremap <expr> <C-k> repeat('<Del>', strchars(getcmdline()[getcmdpos() - 1:]))

" insert
inoremap <silent> <C-r><C-r> <C-r><C-r>*
inoremap <C-k> <C-o>D
inoremap <expr> <Tab>   pumvisible() ? '<C-n>' : '<Tab>'
inoremap <expr> <S-Tab> pumvisible() ? '<C-p>' : '<S-Tab>'

" visual
xnoremap p P
xnoremap <silent> y y`]
xnoremap x "_x
xnoremap < <gv
xnoremap > >gv
xnoremap <silent><C-k> :m'<-2<CR>gv=gv
xnoremap <silent><C-j> :m'>+1<CR>gv=gv
xnoremap S "zy:%s/<C-r>z//gce<Left><Left><Left><Left>
" ref: github.com/monaqa/dotfiles/blob/master/.config/nvim/scripts/keymap.vim#L65-L66
xnoremap * "zy/\V<C-r><C-r>=substitute(escape(@z, '/\'), '\_s\+', '\\_s\\+', 'g')<CR><CR>``
xnoremap # "zy?\V<C-r><C-r>=substitute(escape(@z, '/\'), '\_s\+', '\\_s\\+', 'g')<CR><CR>``
xnoremap R "zy:,$s//<C-r><C-r>=escape(@z, '/\&~')<CR>/gce<Bar>1,''-&&<CR>

" operator
onoremap x d

" terminal
tnoremap <C-w><C-n> <C-\><C-n>
tnoremap <C-p> <Up>
tnoremap <C-n> <Down>

" https://qiita.com/monaqa/items/dcd43a53d3040293142a
let s:jp_digraphs = [
      \    ['aa', 'あ'], ['ii', 'い'], ['uu', 'う'], ['ee', 'え'], ['oo', 'お'],
      \    ['aA', 'ぁ'], ['iI', 'ぃ'], ['uU', 'ぅ'], ['eE', 'ぇ'], ['oO', 'ぉ'],
      \    ['Aa', 'ア'], ['Ii', 'イ'], ['Uu', 'ウ'], ['Ee', 'エ'], ['Oo', 'オ'],
      \    ['AA', 'ァ'], ['II', 'ィ'], ['UU', 'ゥ'], ['EE', 'ェ'], ['OO', 'ォ'],
      \    ['nn', 'ん'], ['Nn', 'ン'], ['j(', '（'], ['j)', '）'], ['j[', '「'],
      \    ['j]', '」'], ['j{', '『'], ['j}', '』'], ['j<', '【'], ['j>', '】'],
      \    ['j,', '、'], ['j.', '。'], ['j!', '！'], ['j?', '？'], ['j:', '：'],
      \    ['j0', '０'], ['j1', '１'], ['j2', '２'], ['j3', '３'], ['j4', '４'],
      \    ['j5', '５'], ['j6', '６'], ['j7', '７'], ['j8', '８'], ['j9', '９'],
      \    ['j~', '〜'], ['j/', '・'], ['j ', '　'],
      \  ]
call digraph_setlist(s:jp_digraphs)
noremap f<C-j> f<C-k>j
noremap F<C-j> F<C-k>j
noremap t<C-j> t<C-k>j
noremap T<C-j> T<C-k>j

Keymap xo il <Cmd>call mi#textobject#line()<CR>
Keymap xo al <Cmd>call mi#textobject#line({'no_trim': 1})<CR>
Keymap xo iu <Cmd>call mi#textobject#fname()<CR>
Keymap xo iy <Cmd>call mi#textobject#lastpaste()<CR>
Keymap xo id <Cmd>call mi#textobject#datetime()<CR>
Keymap xo iA <Cmd>call mi#textobject#alphabet()<CR>
Keymap xo aA <Cmd>call mi#textobject#alphabet({'with_num': 1})<CR>
Keymap xo ie <Cmd>call mi#textobject#entire()<CR>
Keymap xo ae <Cmd>call mi#textobject#entire({'charwise': 1})<CR>
Keymap xo iS <Cmd>call mi#textobject#space()<CR>
Keymap xo aS <Cmd>call mi#textobject#space({'with_tab': 1})<CR>
Keymap xo io <Cmd>call mi#textobject#outline()<CR>
Keymap xo ao <Cmd>call mi#textobject#outline({'from_parent': 1, 'with_blank': 1})<CR>

if !has('nvim')
  Keymap xo i<space> <cmd>call mi#textobject#between(' ', 0)<cr>
  Keymap xo a<space> <cmd>call mi#textobject#between(' ', 1)<cr>
  Keymap xo i<bar> <cmd>call mi#textobject#between("\<bar>", 0)<cr>
  Keymap xo a<bar> <cmd>call mi#textobject#between("\<bar>", 1)<cr>
  " does not works <bslash>...
  " Keymap xo i<bslash> <cmd>call mi#textobject#between("\<bslash>", 0)<cr>
  " Keymap xo a<bslash> <cmd>call mi#textobject#between("\<bslash>", 1)<cr>
  for i in range(33, 126)
    let c = nr2char(i)
    if c !~ '[[:punct:]]' || stridx('\|<>(){}[]"`''', c) >= 0
      continue
    endif
    execute 'Keymap xo i' .. c .. ' <cmd>call mi#textobject#between(''' .. c .. ''', 0)<cr>'
    execute 'Keymap xo a' .. c .. ' <cmd>call mi#textobject#between(''' .. c .. ''', 1)<cr>'
  endfor
endif

" {{{ Rename
" https://vim-jp.org/vim-users-jp/2009/05/27/Hack-17.html
command! -nargs=1 -complete=file Rename
      \ execute 'autocmd BufWritePost <buffer> ++once call delete("' .. expand('%') .. '")' |
      \ file <args>
" }}}

" {{{ EditProjectMru()
" https://zenn.dev/kawarimidoll/articles/057e0c26c6d6e3
function! EditProjectMru() abort
  execute 'edit' get(mi#mru#list(v:true), 0, '')
endfunction
" }}}

function! s:apply_user_highlight() abort
  highlight Reverse    cterm=reverse gui=reverse
  highlight Pmenu      ctermfg=254 ctermbg=237 guifg=#e3e1e4 guibg=#37343a
  highlight PmenuSel   ctermfg=237 ctermbg=254 guifg=#37343a guibg=#e3e1e4
  highlight PmenuSbar  ctermbg=238 guibg=#423f46
  highlight PmenuThumb ctermbg=255 guibg=#f8f8f2
  highlight Underlined ctermfg=NONE cterm=underline guifg=NONE gui=underline
  highlight ExtraWhitespace ctermbg=darkmagenta guibg=darkmagenta
endfunction

augroup vimrc
  autocmd!

  " remove function because it is only for `$ vim -c 'call EditProjectMru()'`
  autocmd VimEnter * ++once delfunction! EditProjectMru

  autocmd VimEnter * ++once
        \ execute 'autocmd BufEnter,BufReadPost * call mi#mru#save()'

  " visualize autocmds
  " autocmd FileType * echomsg 'au FileType '.. expand('<amatch>')
  " autocmd BufEnter * echomsg 'au BufEnter '.. expand('<amatch>')
  " autocmd BufRead * echomsg 'au BufRead '.. expand('<amatch>')
  " autocmd BufWinEnter * echomsg 'au BufWinEnter '.. expand('<amatch>')
  " autocmd WinEnter * echomsg 'au WinEnter '.. expand('<amatch>')
  " autocmd TabEnter * echomsg 'au TabEnter '.. expand('<amatch>')
  " autocmd WinNew * echomsg 'au WinNew '.. expand('<amatch>')
  " autocmd TabNew * echomsg 'au TabNew '.. expand('<amatch>')
  " autocmd VimEnter * echomsg 'au VimEnter '.. expand('<amatch>')

  " Highlight extra whitespaces
  " https://zenn.dev/kawarimidoll/articles/450a1c7754bde6
  " u00A0 ' ' no-break space
  " u2000 ' ' en quad
  " u2001 ' ' em quad
  " u2002 ' ' en space
  " u2003 ' ' em space
  " u2004 ' ' three-per em space
  " u2005 ' ' four-per em space
  " u2006 ' ' six-per em space
  " u2007 ' ' figure space
  " u2008 ' ' punctuation space
  " u2009 ' ' thin space
  " u200A ' ' hair space
  " u200B '​' zero-width space
  " u3000 '　' ideographic (zenkaku) space
  autocmd VimEnter,WinEnter * if !exists('w:highlight_extra_whitespace')
        \ | let w:highlight_extra_whitespace = matchadd('ExtraWhitespace', "[\u00A0\u2000-\u200B\u3000]")
        \ | endif
  autocmd ColorScheme * call s:apply_user_highlight()

  autocmd VimEnter * ++once call mi#git#ensure_root()

  autocmd TextYankPost * call mi#register#collect_yank_history(10)
  autocmd VimEnter * ++once call mi#register#clear()

  autocmd BufNewFile * ++nested call mi#open#reopen_with_lnum()

  if has('nvim')
    " https://jdhao.github.io/2020/05/22/highlight_yank_region_nvim/
    autocmd TextYankPost * silent! lua vim.highlight.on_yank({ timeout=500 })
    autocmd TermOpen * if exists('w:highlight_extra_whitespace') && exists('b:terminal_job_id')
          \ | silent! call matchdelete(w:highlight_extra_whitespace)
          \ | endif
  else
    " https://www.statox.fr/posts/2020/07/vim_flash_yanked_text/
    autocmd TextYankPost * silent! call mi#highlight#on_yank({ 'timeout': 500 })

    if has('vim_starting')
      execute 'colorscheme' ['desert', 'slate', 'habamax'][rand(srand()) % 3]
    endif

    autocmd InsertEnter * ++once call mi#pair#keymap_set(['{}', '[]', '()', "''", '""', '``'])

    autocmd FileType qf call mi#qf#fit_window(3, 10)
    autocmd WinEnter * call mi#qf#quit_if_last_buf()

    autocmd CursorMoved * call mi#highlight#cursorword('Underlined')
    autocmd CursorMoved,CursorMovedI * call mi#highlight#match_paren('Underlined')
  endif

  " {{{ restore-cursor
  " :h restore-cursor
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |   execute 'normal! g`"'
        \ |   execute 'normal! zz'
        \ | endif
  " }}}

  " {{{ ensure_dir
  " https://vim-jp.org/vim-users-jp/2011/02/20/Hack-202.html
  function! s:ensure_dir(dir)
    if !isdirectory(a:dir) && confirm('"' . a:dir . '" does not exist. Create?', "y\nN")
      call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
    endif
  endfunction
  autocmd BufWritePre * call s:ensure_dir(expand('<afile>:p:h'))
  " }}}
augroup END
